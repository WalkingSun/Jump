2018-08-17 18:20:57：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.newPost</methodName>
<params>
    <param>
        <value>
        <string>1</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>测试</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>1111</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

2018-08-17 18:21:02：response is empty

2018-08-17 18:27:49：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.editPost</methodName>
<params>
    <param>
        <value>
        <string>9334245</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>猴子选大王【PHP】</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>[TOC]
# 猴子选大王

一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。

## 指针解决
思考了下，发现数组指针最适合解决这个问题，解决方法：
```php
function monkeyKing($m,$n){
    $arr = range(1,$n);
    $i = 1;
    while( count($arr)&gt;1 ){

        //移动指针，如果是底部移向顶部
        if( $i&gt;1 &amp;&amp; empty($SF) ){
            $sta = next($arr);
            if( !$sta ){
                reset($arr);
            }
            $sta = current($arr);
        }

        $SF = 0;

        //去除m倍数的值，如果是底部移向顶部，并做标记
        if( $i%$m==0 ){
            if(!next($arr)){
                reset($arr);
                current($arr);
            }

            $key = array_search($sta, $arr);    //获取key
            unset($arr[$key]);
            $SF = 1;
        }
        $i++;
    }

    return array_pop($arr);
}
```

测试数据：
```
print_r( monkeyKing(1,3));      //返回 3
print_r( monkeyKing(4,4));      //返回 2
print_r( monkeyKing(3,10));      //返回 4
```
 
挺有意思。


## 数组压栈
```php
function monkeyKing( $m , $n ){
        $arr = range(1,$n);

        $i = 1;
        //for循环 数组压栈数据不计入，遍历结束重新遍历
        while(  count($arr)!=1 ){
            foreach ($arr as $k =&gt; $v){
                unset($arr[$k]);
                if( $i%$m!=0 ){
                    array_push($arr,$v);
                }
                $i++;
            }
        }
        return $arr;
    }
```</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                        <value>
                            <string>[随笔分类]PHP</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

2018-08-17 18:27:50：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.editPost</methodName>
<params>
    <param>
        <value>
        <string>9494462</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>生成器来解决大文件读取，大数据下载</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>[TOC]

# 场景
电商平台想要导出一年的报表数据，数据可能有百万，平常的做法是查出所有数据放到数组或对象中，再进行excel导出，一般情况下，数据不是很多这种是没什么问题，但百万级别的数据一下读到内存中，服务器会一下崩溃，内存溢出。通常情况下也不会做这种需求，产品提出来你可以骂两句怼回去，但老板说我就需要这个功能，你苦口婆心说几句，但是还是要做啊。生成器可以帮我做到这些,理解概念可以看看[这里](https://www.cnblogs.com/followyou/p/9291292.html)。

# 下载文件
```php
  //实现下载大文件，解决内存溢出
    public function actionExport(){

        $filename =  &apos;sun.csv&apos;; //设置文件名
        header(&apos;Content-Type: text/csv&apos;);
        header(&quot;Content-Disposition: attachment;filename={$filename}&quot;);

        $fp = fopen(&apos;php://output&apos;, &apos;w&apos;);

        $sql = &apos;select * from &quot;SCM_tbIOStockDtl&quot;&apos;;

        //非迭代器实现  十万多条数据，导出csv服务器直接崩溃,内存溢出
//        $list = Yii::$app-&gt;db-&gt;createCommand($sql)-&gt;queryAll();

        //PDO::query() 本身由迭代器实现
        $pdo = new \PDO(&apos;pgsql:host=192.168.33.30;port=5432;dbname=jump&apos;, &apos;postgres&apos;, &apos;123456&apos;);
        $pdo-&gt;setAttribute(\PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);
        $list = $pdo-&gt;query($sql);

        foreach ( $list  as  $fields ) {
            fputcsv ( $fp ,  $fields );
        }

        fclose ( $fp );
    }
```

# 读取大文件
```
  //读取大文件
    public function actionRead(){

        $result = $this-&gt;readCsv(Yii::$app-&gt;basePath.&apos;/web/file/sun.csv&apos;);

        foreach ($result as $v){
            echo &quot;&lt;pre&gt;&quot;;
            var_dump( $v);
            echo &quot;&lt;/pre&gt;&quot;;
        }

    }

    #生成器
    function readCsv( $file ){

        $fp = fopen($file,&apos;rb&apos;);

        while( !feof($fp) ){
            yield fgetcsv($fp);
        }

        fclose($fp);
    }
```

代码细节可以看我的[github片段](https://github.com/WalkingSun/Jump/blob/master/controllers/SiteController.php)</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                        <value>
                            <string>[随笔分类]PHP</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

2018-08-19 11:05:02：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.editPost</methodName>
<params>
    <param>
        <value>
        <string>9334245</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>猴子选大王【PHP】</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>[TOC]
# 猴子选大王

一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。

## 指针解决
思考了下，发现数组指针最适合解决这个问题，解决方法：
```php
function monkeyKing($m,$n){
    $arr = range(1,$n);
    $i = 1;
    while( count($arr)&gt;1 ){

        //移动指针，如果是底部移向顶部
        if( $i&gt;1 &amp;&amp; empty($SF) ){
            $sta = next($arr);
            if( !$sta ){
                reset($arr);
            }
            $sta = current($arr);
        }

        $SF = 0;

        //去除m倍数的值，如果是底部移向顶部，并做标记
        if( $i%$m==0 ){
            if(!next($arr)){
                reset($arr);
                current($arr);
            }

            $key = array_search($sta, $arr);    //获取key
            unset($arr[$key]);
            $SF = 1;
        }
        $i++;
    }

    return array_pop($arr);
}
```

测试数据：
```
print_r( monkeyKing(1,3));      //返回 3
print_r( monkeyKing(4,4));      //返回 2
print_r( monkeyKing(3,10));      //返回 4
```
 
挺有意思。


## 数组压栈
```php
function monkeyKing( $m , $n ){
        $arr = range(1,$n);

        $i = 1;
        //for循环 数组压栈数据不计入，遍历结束重新遍历
        while(  count($arr)!=1 ){
            foreach ($arr as $k =&gt; $v){
                unset($arr[$k]);
                if( $i%$m!=0 ){
                    array_push($arr,$v);
                }
                $i++;
            }
        }
        return $arr;
    }
```</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                        <value>
                            <string>[随笔分类]PHP</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

2018-08-19 11:05:06：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.editPost</methodName>
<params>
    <param>
        <value>
        <string>9334245</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>猴子选大王【PHP】</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>[TOC]
# 猴子选大王

一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。

## 指针解决
思考了下，发现数组指针最适合解决这个问题，解决方法：
```php
function monkeyKing($m,$n){
    $arr = range(1,$n);
    $i = 1;
    while( count($arr)&gt;1 ){

        //移动指针，如果是底部移向顶部
        if( $i&gt;1 &amp;&amp; empty($SF) ){
            $sta = next($arr);
            if( !$sta ){
                reset($arr);
            }
            $sta = current($arr);
        }

        $SF = 0;

        //去除m倍数的值，如果是底部移向顶部，并做标记
        if( $i%$m==0 ){
            if(!next($arr)){
                reset($arr);
                current($arr);
            }

            $key = array_search($sta, $arr);    //获取key
            unset($arr[$key]);
            $SF = 1;
        }
        $i++;
    }

    return array_pop($arr);
}
```

测试数据：
```
print_r( monkeyKing(1,3));      //返回 3
print_r( monkeyKing(4,4));      //返回 2
print_r( monkeyKing(3,10));      //返回 4
```
 
挺有意思。


## 数组压栈
```php
function monkeyKing( $m , $n ){
        $arr = range(1,$n);

        $i = 1;
        //for循环 数组压栈数据不计入，遍历结束重新遍历
        while(  count($arr)!=1 ){
            foreach ($arr as $k =&gt; $v){
                unset($arr[$k]);
                if( $i%$m!=0 ){
                    array_push($arr,$v);
                }
                $i++;
            }
        }
        return $arr;
    }
```</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                        <value>
                            <string>[随笔分类]PHP</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

2018-08-19 11:05:06：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.editPost</methodName>
<params>
    <param>
        <value>
        <string>9334245</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>猴子选大王【PHP】</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>[TOC]
# 猴子选大王

一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。

## 指针解决
思考了下，发现数组指针最适合解决这个问题，解决方法：
```php
function monkeyKing($m,$n){
    $arr = range(1,$n);
    $i = 1;
    while( count($arr)&gt;1 ){

        //移动指针，如果是底部移向顶部
        if( $i&gt;1 &amp;&amp; empty($SF) ){
            $sta = next($arr);
            if( !$sta ){
                reset($arr);
            }
            $sta = current($arr);
        }

        $SF = 0;

        //去除m倍数的值，如果是底部移向顶部，并做标记
        if( $i%$m==0 ){
            if(!next($arr)){
                reset($arr);
                current($arr);
            }

            $key = array_search($sta, $arr);    //获取key
            unset($arr[$key]);
            $SF = 1;
        }
        $i++;
    }

    return array_pop($arr);
}
```

测试数据：
```
print_r( monkeyKing(1,3));      //返回 3
print_r( monkeyKing(4,4));      //返回 2
print_r( monkeyKing(3,10));      //返回 4
```
 
挺有意思。


## 数组压栈
```php
function monkeyKing( $m , $n ){
        $arr = range(1,$n);

        $i = 1;
        //for循环 数组压栈数据不计入，遍历结束重新遍历
        while(  count($arr)!=1 ){
            foreach ($arr as $k =&gt; $v){
                unset($arr[$k]);
                if( $i%$m!=0 ){
                    array_push($arr,$v);
                }
                $i++;
            }
        }
        return $arr;
    }
```</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                        <value>
                            <string>[随笔分类]PHP</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

2018-08-19 21:43:02：<?xml version="1.0" encoding="utf-8"?>
<methodCall>
<methodName>metaWeblog.editPost</methodName>
<params>
    <param>
        <value>
        <string>9334245</string>
        </value>
    </param>
    <param>
        <value>
        <string>jueze</string>
        </value>
    </param>
    <param>
        <value>
        <string>yi877900230!</string>
        </value>
    </param>
    <param>
       <value>
        <struct>
            <member>
              <name>title</name>
              <value>
                <string>猴子选大王【PHP】</string>
              </value>
            </member>
            <member>
              <name>description</name>
              <value>
                <string>[TOC]
# 猴子选大王

一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。

## 指针解决
思考了下，发现数组指针最适合解决这个问题，解决方法：
```php
function monkeyKing($m,$n){
    $arr = range(1,$n);
    $i = 1;
    while( count($arr)&gt;1 ){

        //移动指针，如果是底部移向顶部
        if( $i&gt;1 &amp;&amp; empty($SF) ){
            $sta = next($arr);
            if( !$sta ){
                reset($arr);
            }
            $sta = current($arr);
        }

        $SF = 0;

        //去除m倍数的值，如果是底部移向顶部，并做标记
        if( $i%$m==0 ){
            if(!next($arr)){
                reset($arr);
                current($arr);
            }

            $key = array_search($sta, $arr);    //获取key
            unset($arr[$key]);
            $SF = 1;
        }
        $i++;
    }

    return array_pop($arr);
}
```

测试数据：
```
print_r( monkeyKing(1,3));      //返回 3
print_r( monkeyKing(4,4));      //返回 2
print_r( monkeyKing(3,10));      //返回 4
```
 
挺有意思。


## 数组压栈
```php
function monkeyKing( $m , $n ){
        $arr = range(1,$n);

        $i = 1;
        //for循环 数组压栈数据不计入，遍历结束重新遍历
        while(  count($arr)!=1 ){
            foreach ($arr as $k =&gt; $v){
                unset($arr[$k]);
                if( $i%$m!=0 ){
                    array_push($arr,$v);
                }
                $i++;
            }
        }
        return $arr;
    }
```</string>
              </value>
            </member>
            <member>
                <name>categories</name>
                <value>
                  <array>
                    <data>
                        <value>
                            <string>[Markdown]</string>
                        </value>
                        <value>
                            <string>[随笔分类]PHP</string>
                        </value>
                     </data>
                   </array>
                  </value>
            </member>
        </struct>
       </value>
    </param>
    <param>
       <value>
        <boolean>1</boolean>
       </value>
    </param>
</params></methodCall>

