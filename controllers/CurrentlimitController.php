<?php
/**
 * Created by PhpStorm.
 * User: zhaoyu
 * Date: 2019/6/8
 * Time: 7:37 PM
 */

namespace app\controllers;


use app\models\Common;
use yii\web\Controller;

class CurrentlimitController extends Controller
{
    public $userid;

    public function beforeAction($action)
    {
        //限流措施 令牌桶算法
        $this->userid = rand(1,100).time().rand(1,999999);
        if( !$this->tokenBucket() ){
//            Common::addLog('limit.log',$this->userid.' 访问失败',1);
        }
//        Common::addLog('limit.log',$this->userid.' 访问成功');


        return parent::beforeAction($action); // TODO: Change the autogenerated stub
    }


    public function actionIndex(){
        echo 1111;
        die;
    }

    //获取当前时间戳（毫秒）
    function microtime_float()
    {
        list($usec, $sec) = explode(" ", microtime());
        return ((float)$usec + (float)$sec);
    }

    # 令牌桶 悲观锁
    function tokenBucket_bak(): bool
    {
        $redis = \Yii::$app->redis;
        $r = 5;  //每秒投放令牌数
        $c = 20;  //桶总容量

        $lock = $redis->set('lock',1,'EX',60,'NX');
        if( !$lock ){
            return $this->tokenBucket();
        }
        $w = $redis->get('w')?:0;   //桶剩余容量,初始值为满容量
        $preTime = $redis->get('preTime')?:0;   //前一个请求的时间点，初始值为0
        $nowTime = $this->microtime_float();  //当前请求时间点

        $w = min($c,intval($w+($nowTime-$preTime)*$r));//当前剩余容量

        $redis->set('preTime',$nowTime,'EX',3600);
        $redis->set('w',$w,'EX',3600);

        Common::addLog('limit.log',$this->userid.'_'.$preTime.'_'.$nowTime.'_'.$w);

        if( $w>0 ){
            $redis->decr('w');
            $redis->del('lock');
            return true;
        }else{
            $redis->del('lock');
            return false;
        }
    }

    # 令牌桶 redis+lua实现
    public function tokenBucket():bool
    {
        $redis = \Yii::$app->redis;

//        $lua = <<<SCRIPT
//      return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}
//SCRIPT;
//
//        //对应的redis命令如下 eval "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}" 2 key1 key2 first second
//        $s = $redis->eval($lua,2,'key1','key2','first','second');
//        var_dump($s);die;

        //w = min(c,(当前时间-上次时间)*限制速度)
        $lua = "
        local data = redis.call('get',KEYS[1])
        if(data)
        then
           local dataJson = cjson.decode(data)
           local residualCapacity = math.min(KEYS[2],dataJson['residualCapacity']+(KEYS[4]-dataJson['curTime'])*KEYS[3])
           residualCapacity = math.floor(residualCapacity)
           if( residualCapacity>0 )
           then
               local setData = cjson.encode({residualCapacity=(residualCapacity-1),curTime=KEYS[4],preTime=dataJson['curTime']})
               redis.call('set',KEYS[1],setData,'EX',KEYS[5])
           else
               return -1
           end
        else
             local setData = cjson.encode({residualCapacity=KEYS[2],curTime=KEYS[4]})
             redis.call('set',KEYS[1],setData,'EX',KEYS[5])
        end
        
        return redis.call('get',KEYS[1])
        ";

        $key='current_limit';
        $nowTime = $this->microtime_float();  //当前请求时间点
        $capacity=20;  //桶容量
        $tokenSpeed=10;   //令牌生成速度

        $tokenRes = $redis->eval($lua,5,$key,$capacity,$tokenSpeed,$nowTime,$key_timeout=3600);

        Common::addLog('limit.log',$this->userid.'_'.$nowTime.'_'.var_export($tokenRes,1));

        if( $tokenRes!=-1 )
            return true;
        else
            return false;
    }
}