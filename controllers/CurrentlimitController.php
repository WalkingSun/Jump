<?php
/**
 * Created by PhpStorm.
 * User: zhaoyu
 * Date: 2019/6/8
 * Time: 7:37 PM
 */

namespace app\controllers;


use app\models\Common;
use yii\web\Controller;

class CurrentlimitController extends Controller
{
    public $userid;

    public function beforeAction($action)
    {
        //限流措施 令牌桶算法
        $this->userid = rand(1,100).time().rand(1,999999);

        //令牌桶限流
//        $this->tokenBucket();

        //漏桶限流
        $this->leakyBucket();

        return parent::beforeAction($action); // TODO: Change the autogenerated stub
    }


    public function actionIndex(){
        echo 1111;
        die;
    }

    //获取当前时间戳（毫秒）
    function microtime_float()
    {
        list($usec, $sec) = explode(" ", microtime());
        return ((float)$usec + (float)$sec);
    }

    # 令牌桶 悲观锁
    function tokenBucket_bak(): bool
    {
        $redis = \Yii::$app->redis;
        $r = 5;  //每秒投放令牌数
        $c = 20;  //桶总容量

        $lock = $redis->set('lock',1,'EX',60,'NX');
        if( !$lock ){
            return $this->tokenBucket();
        }
        $w = $redis->get('w')?:0;   //桶剩余容量,初始值为满容量
        $preTime = $redis->get('preTime')?:0;   //前一个请求的时间点，初始值为0
        $nowTime = $this->microtime_float();  //当前请求时间点

        $w = min($c,intval($w+($nowTime-$preTime)*$r));//当前剩余容量

        $redis->set('preTime',$nowTime,'EX',3600);
        $redis->set('w',$w,'EX',3600);

        Common::addLog('limit.log',$this->userid.'_'.$preTime.'_'.$nowTime.'_'.$w);

        if( $w>0 ){
            $redis->decr('w');
            $redis->del('lock');
            return true;
        }else{
            $redis->del('lock');
            return false;
        }
    }

    # 令牌桶 redis+lua实现
    public function tokenBucket():bool
    {
        $redis = \Yii::$app->redis;

        //w = min(c,(当前时间-上次时间)*限制速度)
        $lua = "
        local data = redis.call('get',KEYS[1])
        if(data)
        then
           local dataJson = cjson.decode(data)
           local residualCapacity = math.min(KEYS[2],dataJson['residualCapacity']+(KEYS[4]-dataJson['curTime'])*KEYS[3])
           residualCapacity = math.floor(residualCapacity)
           if( residualCapacity>0 )
           then
               local setData = cjson.encode({residualCapacity=(residualCapacity-1),curTime=KEYS[4],preTime=dataJson['curTime']})
               redis.call('set',KEYS[1],setData,'EX',KEYS[5])
           else
               return -1
           end
        else
             local setData = cjson.encode({residualCapacity=KEYS[2],curTime=KEYS[4]})
             redis.call('set',KEYS[1],setData,'EX',KEYS[5])
        end
        
        return redis.call('get',KEYS[1])
        ";

        $key='current_limit';
        $nowTime = $this->microtime_float();  //当前请求时间点
        $capacity=20;  //桶容量
        $tokenSpeed=10;   //令牌生成速度

        $tokenRes = $redis->eval($lua,5,$key,$capacity,$tokenSpeed,$nowTime,$key_timeout=3600);

        Common::addLog('limit.log',$this->userid.'_'.$nowTime.'_'.var_export($tokenRes,1));

        if( $tokenRes!=-1 )
            return true;
        else
           die('fail');
    }

    //漏桶限流
    public function leakyBucket(){

        $key = 'leakyBucketCurrentLimit';
        $capacity = 10; //桶容量
        $outflowSpeed = 10;  //流出速度
        $nowTime = $this->microtime_float();  //当前请求时间点

        $lua = "
            local data = redis.call('get',KEYS[1])
            if data
            then
                local dataJson = cjson.decode(data)
                local capacity = math.max(math.ceil( dataJson['residualCapacity']-(KEYS[4]-dataJson['curTime'])*KEYS[3] ),0)
                if capacity-KEYS[2]>0
                then
                    return -1
                else
                    local setData = cjson.encode({residualCapacity=(capacity+1),curTime=KEYS[4],preTime=dataJson['curTime']})
                    redis.call('set',KEYS[1],setData,'EX',KEYS[5])
                end
            else
               local setData = cjson.encode({residualCapacity=0,curTime=KEYS[4]})
               redis.call('set',KEYS[1],setData,'EX',KEYS[5])
            end   
   
           return redis.call('get',KEYS[1])
        ";

        $redis = \Yii::$app->redis;
        $tokenRes = $redis->eval($lua,5,$key,$capacity,$outflowSpeed,$nowTime,$key_timeout=3600);

        Common::addLog('limit.log',$this->userid.'_'.$nowTime.'_'.var_export($tokenRes,1));


        if( $tokenRes!=-1 )
            return true;
        else
            die('fail');

    }


}